"""
Briefing routes â€“ serves the Daily Morning Briefing to the frontend.
Also serves pre-generated workout reviews from the database (auto-generated by scheduler).
"""
import logging
from datetime import date
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.database import get_db
from app.dependencies import get_current_user
from app.models import User, MorningBriefing, WorkoutReview, WeightEntry
from app.schemas import BriefingResponse
from app.services.aggregator import gather_user_context
from app.services.ai_service import generate_daily_briefing, generate_session_review, generate_workout_tips, generate_chat_response
from app.services.weather_service import fetch_weather
from app.services.hevy_service import fetch_workout_dates
from app.services.yazio_service import fetch_nutrition_dates
from app.encryption import decrypt_value

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/briefing", tags=["Briefing"])


def _log_weight_entry(user_id, yazio_data: Optional[dict], db: Session):
    """Log today's weight from Yazio data into weight_entries (idempotent)."""
    if not yazio_data or not yazio_data.get("profile"):
        return
    weight = yazio_data["profile"].get("current_weight_kg")
    if not weight or weight <= 0:
        return
    today = date.today()
    existing = (
        db.query(WeightEntry)
        .filter(WeightEntry.user_id == user_id, WeightEntry.date == today)
        .first()
    )
    if existing:
        # Update if weight changed
        if abs(existing.weight_kg - weight) > 0.01:
            existing.weight_kg = weight
            db.commit()
        return
    entry = WeightEntry(user_id=user_id, date=today, weight_kg=round(weight, 2))
    db.add(entry)
    try:
        db.commit()
    except Exception:
        db.rollback()


async def _generate_and_save(
    user: User, db: Session, weather_data: Optional[dict] = None
) -> MorningBriefing:
    """
    Run the full pipeline: gather data â†’ call AI â†’ persist.
    """
    today = date.today()
    lang = user.language or "de"

    # 1) Aggregate Yazio + Hevy data
    context = await gather_user_context(user)

    # Save first_name from Yazio profile if available
    yazio = context.get("yazio")
    if yazio and yazio.get("profile"):
        fn = yazio["profile"].get("first_name", "").strip()
        if fn and fn != (user.first_name or ""):
            user.first_name = fn
            db.commit()
            db.refresh(user)

    # Log weight entry from Yazio
    _log_weight_entry(user.id, yazio, db)

    # Fetch weight history for AI context
    weight_history = (
        db.query(WeightEntry)
        .filter(WeightEntry.user_id == user.id)
        .order_by(WeightEntry.date.desc())
        .limit(90)
        .all()
    )
    weight_history_data = [
        {"date": e.date.isoformat(), "weight_kg": e.weight_kg}
        for e in reversed(weight_history)
    ]

    # 2) Call Gemini
    briefing_data = await generate_daily_briefing(
        yazio_data=context["yazio"],
        hevy_data=context["hevy"],
        weather_data=weather_data,
        language=lang,
        weight_history=weight_history_data,
    )

    # 3) Persist
    briefing = MorningBriefing(
        user_id=user.id,
        date=today,
        briefing_data=briefing_data,
    )
    db.add(briefing)
    try:
        db.commit()
        db.refresh(briefing)
    except Exception:
        db.rollback()
        existing = (
            db.query(MorningBriefing)
            .filter(MorningBriefing.user_id == user.id, MorningBriefing.date == today)
            .first()
        )
        if existing:
            return existing
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save briefing",
        )

    logger.info("Briefing generated for user %s on %s", user.id, today)
    return briefing


@router.get("/today", response_model=BriefingResponse)
async def get_todays_briefing(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    lat: Optional[float] = Query(None),
    lon: Optional[float] = Query(None),
):
    """
    Return today's morning briefing.
    If one already exists in the DB â†’ return it immediately.
    If not â†’ generate on-demand (optionally with weather), save, and return.
    """
    today = date.today()

    existing = (
        db.query(MorningBriefing)
        .filter(MorningBriefing.user_id == current_user.id, MorningBriefing.date == today)
        .first()
    )
    if existing:
        return existing

    # Fetch weather if location provided
    weather_data = None
    if lat is not None and lon is not None:
        weather_data = await fetch_weather(lat, lon)

    return await _generate_and_save(current_user, db, weather_data)


@router.post("/regenerate", response_model=BriefingResponse)
async def regenerate_briefing(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    lat: Optional[float] = Query(None),
    lon: Optional[float] = Query(None),
):
    """
    Force-regenerate today's briefing (deletes the old one if present).
    """
    today = date.today()

    db.query(MorningBriefing).filter(
        MorningBriefing.user_id == current_user.id,
        MorningBriefing.date == today,
    ).delete()
    db.commit()

    weather_data = None
    if lat is not None and lon is not None:
        weather_data = await fetch_weather(lat, lon)

    return await _generate_and_save(current_user, db, weather_data)


@router.get("/weather")
async def get_weather(
    lat: float = Query(...),
    lon: float = Query(...),
    current_user: User = Depends(get_current_user),
):
    """
    Return current weather data for the user's location.
    Used by the frontend header for real-time display.
    """
    data = await fetch_weather(lat, lon)
    if not data:
        return {"temperature_c": None, "condition": "Unknown", "emoji": "ğŸŒ¡ï¸"}
    return data


@router.post("/session-review")
async def get_session_review(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Session review â€” tries to return a pre-generated review from the DB first.
    If none exists, falls back to a live Gemini call (and saves the result).
    Marks the review as read.
    """
    # Try DB first (most recent unread or any recent)
    review = (
        db.query(WorkoutReview)
        .filter(WorkoutReview.user_id == current_user.id)
        .order_by(WorkoutReview.workout_date.desc())
        .first()
    )

    if review and review.review_data:
        # Mark as read
        if not review.is_read:
            review.is_read = True
            db.commit()
        return review.review_data

    # Fallback: generate live (for users who just signed up or have no reviews yet)
    context = await gather_user_context(current_user)

    # Still try to include coaching memory for fallback generation
    previous_review_list = []
    if context.get("hevy") and len(context["hevy"]) > 0:
        latest_workout_name = context["hevy"][0].get("title", "")
        if latest_workout_name:
            prev_reviews = (
                db.query(WorkoutReview)
                .filter(
                    WorkoutReview.user_id == current_user.id,
                    WorkoutReview.workout_name == latest_workout_name,
                )
                .order_by(WorkoutReview.workout_date.desc())
                .limit(3)
                .all()
            )
            previous_review_list = [r.review_data for r in prev_reviews if r.review_data]

    result = await generate_session_review(
        yazio_data=context["yazio"],
        hevy_data=context["hevy"],
        language=current_user.language or "de",
        previous_reviews=previous_review_list,
    )

    return result


@router.get("/workout-reviews")
async def get_workout_reviews(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    limit: int = Query(20, ge=1, le=50),
):
    """
    Return the user's pre-generated workout reviews from the DB.
    Each item includes the review + tips data, sorted newest first.
    """
    reviews = (
        db.query(WorkoutReview)
        .filter(WorkoutReview.user_id == current_user.id)
        .order_by(WorkoutReview.workout_date.desc())
        .limit(limit)
        .all()
    )

    result = []
    for r in reviews:
        result.append({
            "id": str(r.id),
            "hevy_workout_id": r.hevy_workout_id,
            "workout_name": r.workout_name,
            "workout_date": r.workout_date.isoformat() if r.workout_date else "",
            "is_read": r.is_read,
            "has_review": r.review_data is not None,
            "has_tips": r.tips_data is not None,
            "review_data": r.review_data,
            "tips_data": r.tips_data,
            "created_at": r.created_at.isoformat() if r.created_at else "",
        })

    return result


@router.post("/workout-reviews/{review_id}/read")
async def mark_review_read(
    review_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Mark a specific workout review as read."""
    review = (
        db.query(WorkoutReview)
        .filter(WorkoutReview.id == review_id, WorkoutReview.user_id == current_user.id)
        .first()
    )
    if not review:
        raise HTTPException(status_code=404, detail="Review not found")

    review.is_read = True
    db.commit()
    return {"message": "Marked as read"}


@router.get("/unread-count")
async def get_unread_count(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """Return the count of unread workout reviews for badge display."""
    count = (
        db.query(WorkoutReview)
        .filter(
            WorkoutReview.user_id == current_user.id,
            WorkoutReview.is_read == False,
        )
        .count()
    )
    return {"unread_count": count}


@router.post("/trigger-review")
async def trigger_review_check(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Manual trigger â€” immediately checks for new workouts and generates
    reviews for up to 5 that don't have one yet.
    Already-reviewed workouts are ALWAYS skipped (zero token waste).
    """
    from app.scheduler import _generate_workout_review_for_user

    generated = await _generate_workout_review_for_user(
        current_user, db, max_new_reviews=5
    )
    return {
        "message": f"{generated} new review(s) generated" if generated else "All workouts already reviewed â€” no tokens used",
        "new_reviews": generated,
    }


@router.get("/workouts")
async def get_workout_list(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Return the user's recent workouts as a lightweight list for the picker.
    No AI involved â€“ just fetches from Hevy.
    """
    context = await gather_user_context(current_user)
    workouts = context.get("hevy") or []

    # Return a simplified list with index, title, date, exercises, duration
    result = []
    for i, w in enumerate(workouts):
        exercise_names = [ex.get("title", "?") for ex in w.get("exercises", [])]
        result.append({
            "index": i,
            "title": w.get("title", "Workout"),
            "date": (w.get("start_time") or "")[:10],
            "duration_min": w.get("duration_min"),
            "exercise_names": exercise_names,
        })

    return result


class WorkoutTipsRequest(BaseModel):
    workout_index: int


@router.post("/workout-tips")
async def get_workout_tips(
    body: WorkoutTipsRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Workout tips â€” if a pre-generated review exists for the selected workout,
    returns its tips_data instantly. Otherwise generates live with coaching memory.
    """
    context = await gather_user_context(current_user)
    workouts = context.get("hevy") or []

    if body.workout_index < 0 or body.workout_index >= len(workouts):
        raise HTTPException(status_code=400, detail="Invalid workout index")

    selected_workout = workouts[body.workout_index]
    hevy_id = selected_workout.get("id", "")

    # Check if we already have tips in the DB
    if hevy_id:
        existing = (
            db.query(WorkoutReview)
            .filter(
                WorkoutReview.user_id == current_user.id,
                WorkoutReview.hevy_workout_id == str(hevy_id),
            )
            .first()
        )
        if existing and existing.tips_data:
            # Mark as read
            if not existing.is_read:
                existing.is_read = True
                db.commit()
            return existing.tips_data

    # No pre-generated tips â€” generate live with coaching memory (last 3)
    workout_name = selected_workout.get("title", "Workout")
    previous_reviews = (
        db.query(WorkoutReview)
        .filter(
            WorkoutReview.user_id == current_user.id,
            WorkoutReview.workout_name == workout_name,
        )
        .order_by(WorkoutReview.workout_date.desc())
        .limit(3)
        .all()
    )
    previous_tips_list = [r.tips_data for r in previous_reviews if r.tips_data]

    result = await generate_workout_tips(
        yazio_data=context["yazio"],
        hevy_data=workouts,
        workout_index=body.workout_index,
        language=current_user.language or "de",
        previous_tips_list=previous_tips_list,
    )

    return result


@router.get("/activity-heatmap")
async def get_activity_heatmap(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Return workout dates + nutrition tracking dates for a GitHub-style activity heatmap.
    Returns {workouts: [{date, title, duration_min}], nutrition: [{date, calories, protein}]}.
    """
    workout_dates: list[dict] = []
    nutrition_dates: list[dict] = []

    # Fetch workout dates from Hevy
    if current_user.hevy_api_key:
        try:
            api_key = decrypt_value(current_user.hevy_api_key)
            workout_dates = await fetch_workout_dates(api_key, max_pages=20)
        except Exception as exc:
            logger.error("Failed to fetch workout dates: %s", exc)

    # Fetch nutrition tracking dates from Yazio
    if current_user.yazio_email and current_user.yazio_password:
        try:
            email = decrypt_value(current_user.yazio_email)
            password = decrypt_value(current_user.yazio_password)
            nutrition_dates = await fetch_nutrition_dates(email, password, days=180)
        except Exception as exc:
            logger.error("Failed to fetch nutrition dates: %s", exc)

    return {
        "workouts": workout_dates,
        "nutrition": nutrition_dates,
    }


@router.get("/weight-history")
async def get_weight_history(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
    days: int = Query(90, ge=7, le=365),
):
    """
    Return the user's weight history (last N days).
    Data is collected from Yazio on each briefing generation.
    If no entry for today exists, tries to seed from Yazio on the fly.
    """
    from datetime import timedelta
    today_date = date.today()
    cutoff = today_date - timedelta(days=days)

    # Try to seed today's weight if missing
    today_entry = (
        db.query(WeightEntry)
        .filter(WeightEntry.user_id == current_user.id, WeightEntry.date == today_date)
        .first()
    )
    if not today_entry and current_user.yazio_email and current_user.yazio_password:
        try:
            from app.services.yazio_service import fetch_yazio_summary
            email = decrypt_value(current_user.yazio_email)
            password = decrypt_value(current_user.yazio_password)
            yazio_data = await fetch_yazio_summary(email, password)
            _log_weight_entry(current_user.id, yazio_data, db)
        except Exception as exc:
            logger.debug("Could not seed weight from Yazio: %s", exc)

    entries = (
        db.query(WeightEntry)
        .filter(
            WeightEntry.user_id == current_user.id,
            WeightEntry.date >= cutoff,
        )
        .order_by(WeightEntry.date.asc())
        .all()
    )
    return {
        "entries": [
            {"date": e.date.isoformat(), "weight_kg": round(e.weight_kg, 2)}
            for e in entries
        ],
        "start_weight": entries[0].weight_kg if entries else None,
        "current_weight": entries[-1].weight_kg if entries else None,
        "count": len(entries),
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  AI CHAT â€” conversational coaching
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ChatMessage(BaseModel):
    role: str  # "user" or "assistant"
    content: str


class ChatRequest(BaseModel):
    message: str
    conversation_history: list[ChatMessage] = []


@router.post("/chat")
async def coach_chat(
    body: ChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Conversational AI Coach chat. The AI knows the user's nutrition, goals,
    training plan, and recent workouts. It can answer questions about training
    programming, exercise selection, nutrition, and recovery.
    """
    # Gather full context
    context = await gather_user_context(current_user)

    # Convert conversation history to dicts
    history = [{"role": m.role, "content": m.content} for m in body.conversation_history]

    response_text = await generate_chat_response(
        message=body.message,
        conversation_history=history,
        yazio_data=context["yazio"],
        hevy_data=context["hevy"],
        training_plan=current_user.training_plan,
        language=current_user.language or "de",
    )

    return {"response": response_text}
